<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <title>
    Writing Headless Backbone Tests With Node.js // Artsy Engineering
  </title>

  <link href="http://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="craig">
<meta name="generator" content="Hugo 0.26" />

  <meta property="og:title" content="Writing Headless Backbone Tests With Node.js" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="https://hizkifw.github.io/artsy.github.io-hugo/2013/06/14/writing-headless-backbone-tests-with-node-dot-js/" />


  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/base-min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/pure-min.css">
  
  
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/grids-responsive-min.css">
  
  

  <link rel="stylesheet" href="https://hizkifw.github.io/artsy.github.io-hugo/css/redlounge.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='//fonts.googleapis.com/css?family=Raleway:400,200,100,700,300,500,600,800' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Artsy Engineering" />

    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.7/styles/tomorrow-night-bright.min.css">
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.7/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  

  

  

  
</head>

<body>
	

	<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
  <div class="header">
    

	

    
    

    <nav class="nav">
      <ul class="nav-list">
        <li class="nav-item"><span class="nav-item-separator">//</span><a href="https://hizkifw.github.io/artsy.github.io-hugo">Home</a></li>
        
      </ul>
    </nav>

    

  </div>
</div>

	
	

    <div class="content pure-u-1 pure-u-md-3-4">
		<a name="top"></a>
		

		
			
		    <div id="toc" class="pure-u-1 pure-u-md-1-4">
				<small class="toc-label">Contents</small>
		   	 	<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#tl-dr">TL;DR</a></li>
<li><a href="#a-brief-history">A Brief History</a></li>
<li><a href="#setting-up-the-environment">Setting Up The Environment</a></li>
<li><a href="#unit-testing-models">Unit Testing Models</a></li>
<li><a href="#unit-testing-views">Unit Testing Views</a></li>
<li><a href="#integration-tests">Integration Tests</a>
<ul>
<li><a href="#stubbing-the-api-layer">Stubbing the API Layer</a></li>
<li><a href="#headless-integration-tests-with-zombie-js">Headless Integration Tests with Zombie.js</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>
</nav>
		    </div>
		    
	    
  		<section class="post">
            <h1 class="post-title">
              <a href="/artsy.github.io-hugo/2013/06/14/writing-headless-backbone-tests-with-node-dot-js/">Writing Headless Backbone Tests With Node.js</a>
            </h1>
            <h3 class="post-subtitle">
            	
            </h3>
            
            	<span class="post-date">
                	<span class="post-date-day"><sup>14</sup></span><span class="post-date-separator">/</span><span class="post-date-month">Jun</span> <span class="post-date-year">2013</span>
            	</span>
            	
            
            	
            		<span class="post-author-single">By <a class="post-author"  target="">craig</a></span>
            		




            	
            

			
			
				<div class="post-categories">
				
					<a class="post-category post-category-Javascript" href="https://hizkifw.github.io/artsy.github.io-hugo/categories/Javascript">Javascript</a>
				
					<a class="post-category post-category-Backbone.js" href="https://hizkifw.github.io/artsy.github.io-hugo/categories/Backbone.js">Backbone.js</a>
				
					<a class="post-category post-category-Node.js" href="https://hizkifw.github.io/artsy.github.io-hugo/categories/Node.js">Node.js</a>
				
					<a class="post-category post-category-testing" href="https://hizkifw.github.io/artsy.github.io-hugo/categories/testing">testing</a>
				
				</div>
			

			

			

            <h2 id="tl-dr">TL;DR</h2>

<p>Write fast, headless, tests for Backbone using Node.js. See this project as an example  <a href="https://github.com/craigspaeth/backbone-headless-testing">https://github.com/craigspaeth/backbone-headless-testing</a>.</p>

<h2 id="a-brief-history">A Brief History</h2>

<p>Artsy is mostly a thick client <a href="http://backbonejs.org/">Backbone</a> app that sits on <a href="http://rubyonrails.org/">Rails</a> and largely depends on <a href="http://jnicklas.github.io/capybara/">Capybara</a> (<a href="http://docs.seleniumhq.org/">Selenium</a> backed bot that clicks around Firefox) for testing it&rsquo;s javascript. This leads to some seriously brittle and slow integration tests. <a href="http://artsy.github.io/blog/2012/02/03/reliably-testing-asynchronous-ui-w-slash-rspec-and-capybara/">Despite being able to wrangle Capybara</a> to do most of our client-side testing, we knew there must be a better way.</p>

<p>When building a CMS app for our gallery partners to manage their Artsy inventory, we built a new Backbone app on top of <a href="http://nodejs.org/">node.js</a>. The result was a headless test suite that runs around 60 times faster.</p>

<p>Let&rsquo;s take a look at how it&rsquo;s done.</p>

<p></p>

<h2 id="setting-up-the-environment">Setting Up The Environment</h2>

<p>The trick to testing client-side code in node.js is creating an environment that mimics the browser. <a href="https://github.com/tmpvar/jsdom">Jsdom</a> does just that by bringing a pure javascript implementation of the DOM to node.js.</p>

<pre><code class="language-javascript">jsdom.env({
  html: &quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;,
  done: function(errs, window) {
    global.window = window;
    // ...
    callback();
  }
});
</code></pre>

<p>At this point we&rsquo;ve globally exposed the <code>window</code> object of our jsdom browser. However the DOM isn&rsquo;t the only global dependency in most of our client-side code. We&rsquo;ll also need to expose our common libraries like Backbone, Underscore, and jQuery.</p>

<pre><code class="language-javascript">global.window = window;
global.Backbone = require('../app/javascripts/vendor/backbone.js');
global.Underscore = require('../app/javascripts/vendor/underscore.js');
global.jQuery = require('../app/javascripts/vendor/jQuery.js');
</code></pre>

<p>We can simply require Backbone, Underscore, and jQuery like any node module because they follow <a href="http://wiki.CommonJS.org/wiki/Modules/1.1.1">CommonJS</a> convention. However not all libraries are CommonJS compatible, and in this case you might have to expose their attachment to <code>window</code>.</p>

<pre><code class="language-javascript">global.window = window;
require('../app/javascripts/vendor/zepto.js');
global.Zepto = window.Zepto;
</code></pre>

<p>Finally you probably have a namespace like <code>App</code> which your components attach to.</p>

<pre><code class="language-javascript">global.window = window;
// Libraries
global.Backbone = require('../app/javascripts/vendor/backbone.js');
global.Underscore = require('../app/javascripts/vendor/underscore.js');
global.jQuery = require('../app/javascripts/vendor/jQuery.js');
// Namespace
global.App = {};
// We're ready to test some Backbone components
</code></pre>

<p>Try to keep global dependencies to a minimum. This reduces setup/teardown, increases modularity, and makes it easier to test your code.</p>

<p>For example, instead of attaching a view to <code>App</code> it might be better to pass that view in to the options of another so you can call <code>this.options.header.doSomething()</code>.</p>

<h2 id="unit-testing-models">Unit Testing Models</h2>

<p>Because all good javascript guides are based off Todo apps, let&rsquo;s pretend we&rsquo;re testing a Todo model.</p>

<pre><code class="language-javascript">App.Todo = Backbone.Models.extend({

  urlRoot: '/api/todo',

  complete: function() {
    var self = this;
    $.ajax({
      url: '/api/todos/' + this.get('id') + '/complete',
      type: 'PUT',
      success: function() { self.set({ completed: true }); }
    });
  }
});
</code></pre>

<p>Let&rsquo;s test that <code>#complete</code> makes the proper API PUT and <code>completed</code> is updated to true. After we setup our jsdom environment we need to stub <code>$.ajax</code> using <a href="http://sinonjs.org/docs/#stubs">sinon</a> as we won&rsquo;t be sending XHRs in node.</p>

<pre><code class="language-javascript">before(function(done) {
  jsdom.env({
    html: &quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;,
    done: function(errs, window) {
      global.$ = require('../../app/javascripts/vendor/jquery.js');
      //...
    }
  });
});

beforeEach(function(done) {
  ajaxStub = sinon.stub($, 'ajax');
  todo = new App.Todo({ title: 'Feed the cat', id: 'feed-the-cat' });
});
</code></pre>

<p>Now we can simply assert that <code>$.ajax</code> was called with the right params and completed changed.</p>

<pre><code class="language-javascript">it('PUTs to the API', function() {
  todo.complete();
  $.ajax.args[0][0].type.should.equal('PUT');
  $.ajax.args[0][0].url.should
    .equal('/api/todos/feed-the-cat/complete');
});

it('updates the item to be completed', function() {
  todo.set('completed', false);
  $.ajax.args[0][0].success();
  todo.get('completed').should.equal(true);
});
</code></pre>

<h2 id="unit-testing-views">Unit Testing Views</h2>

<p>Models are easy to unit test because they&rsquo;re mostly self-contained javascript. However a Backbone view might expect some server-side rendered HTML, use client-side templates, communicate to other views, and so on. This makes it harder to test but manageable given our set up.</p>

<p>Let&rsquo;s pretend we have a view that renders our todo list inside a server-side rendered element, and uses a client-side template to fill in the actual list items.</p>

<p>Our DOM might look something like this:</p>

<pre><code class="language-html">&lt;div id='todos'&gt;
  &lt;h1&gt;Things I need to do today&lt;/h1&gt;
  &lt;ul class='todos-list'&gt;&lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>and our view might look something like this:</p>

<pre><code class="language-javascript">App.TodosListView = Backbone.View.extend({

  el: '#todos',

  template: JST['todos/list_items'],

  initialize: function() {
    this.collection.bind('add remove', this.render);
  },

  render: function() {
    this.$('.todos-list')
      .html(this.template({ todos: this.collection.models }));
  }
})
</code></pre>

<p>We can render the server-side <code>#todos</code> element by compiling the express view into html and injecting it straight in jsdom with our globally exposed jQuery.</p>

<pre><code class="language-javascript">filename = path.resolve(__dirname, '../app/views/index.jade');
template = fs.readFileSync(filename).toString();
html = jade.compile(template, { filename: filename })();
$('html').html(html);
</code></pre>

<p>Next we need to expose our client-side templates. In this case I&rsquo;m assuming client-side templates are pre-compiled into functions namespaced under a global JST object like in the <a href="http://guides.rubyonrails.org/asset_pipeline.html">Rail&rsquo;s asset pipeline</a> (if you&rsquo;re looking for a node.js tool <a href="https://github.com/craigspaeth/nap">nap</a> is what Artsy uses).</p>

<p>We need to mimic what the JST functions are expecting so that when calling <code>JST['foo/bar']({ foo: 'some-data' })</code> we get back a string of html.</p>

<pre><code class="language-javascript">global.JST = {};
var filename = path.resolve(
  __dirname,
  '../app/javascripts/templates/todos/list.jade'
);
JST['todos/list'] = jade.compile(
  fs.readFileSync(filename).toString(),
  { filename: filename }
);
</code></pre>

<p>With our server-side HTML injected and our client-side templates ready to use, all that&rsquo;s needed is to require any other dependent Backbone components. This boilerplate can get pretty repetitive and would be good to wrap up into a helper.</p>

<pre><code class="language-javascript">var clientenv = require('../helpers/clientenv');

before(function(done) {
  clientenv.setup(function() {
    global.App.Todo = require('../app/javascripts/models/todo.js');
    global.App.Todos = require('../app/javascripts/collections/todos.js');
    done();
  });
});

beforeEach(function(done) {
  var templateFilename = path.resolve(
        __dirname,
        '../../views/index.jade'
      ),
      html = require('jade').compile(
        fs.readFileSync(templateFilename).toString(),
        { filename: templateFilename }
      )();
  $('html').html(html);
  view = new App.TodosListView();
  done();
});

it('renders items as they are added', function() {
  view.collection.add([
    new App.Todo({ title: 'clean the kitchen' })
  ]);
  view.$el.html().should.include('clean the kitchen');
});
</code></pre>

<p>With a little bit more work, testing views in node can be almost as easy as testing models.</p>

<h2 id="integration-tests">Integration Tests</h2>

<p>Although I encourage writing way more unit test coverage as they&rsquo;re faster and less brittle, it is necessary to have integration tests to cover longer scenarios. At Artsy we use some tricks to make integration testing less painful.</p>

<h3 id="stubbing-the-api-layer">Stubbing the API Layer</h3>

<p>In Artsy&rsquo;s case we&rsquo;re consuming a JSON API service that already has ample test coverage, so it makes sense to cut off integration at this point and stub our API responses.</p>

<p>To do this we can conditionally check which environment we&rsquo;re running in and swap out the API to use a real API or an <a href="http://expressjs.com/">express</a> app serving a stubbed API.</p>

<pre><code class="language-javascript">if(app.get('env') == 'test') {
  app.set('api url', 'http://localhost:5000');
  // Create a mock api server in your test helpers
  // and run it on 5000 in a before block
} else {
  app.set('api url', 'http://api.my-app.com');
}
// Bootstrap in your server-side view so the client app
// knows where to point
app.locals.API_URL_ROOT = app.get('api url');
</code></pre>

<p>If our API was hosted on the same server as our client app, or we&rsquo;re proxying API calls because of lack of <a href="http://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">CORS</a> support, this could be as easy as swapping out middleware.</p>

<pre><code class="language-javascript">if(app.get('env') == 'test') {
  app.use('/api', require('./test/helpers/mock_api'));
} else {
  app.use('/api', require('./routes/api'));
}
</code></pre>

<p>This speeds up integration tests and simplifies the stack by not populating a database or booting an API server.</p>

<h3 id="headless-integration-tests-with-zombie-js">Headless Integration Tests with Zombie.js</h3>

<p>Selenium has to actually boot up Firefox and poll the UI to wait for things to appear. This disconnect means extra seconds of &ldquo;wait_util we&rsquo;re sure&rdquo; time.  <a href="http://zombie.labnotes.org/">Zombie.js</a> is backed by our friend jsdom and alleviates these issues by giving us a fast headless browser that we can programmatically access.</p>

<p>Of course the caveat to headless testing is that you can&rsquo;t visually see how a test is actually failing. Using <code>{ debug: true }</code> in your options will spit every Zombie action to stdout. In most cases this is enough, but sometimes you need to go a step further and actually visualize what the test is doing.</p>

<p>A trick we use is to write tests using the browser&rsquo;s <code>jQuery</code>. This is more familiar than Zombie&rsquo;s DSL and lets you copy and paste test code directly in your browser&rsquo;s console to see if it&rsquo;s actually doing what you want.</p>

<p>.e.g</p>

<pre><code class="language-javascript">Browser.visit('http://localhost:5000', function(err, browser) {
  var $ = browser.window.$;

  // From here we can run `NODE_ENV=test node app.js` and copy
  // this code right into our browser's console.
  $('#add-todo').val('Foo').change();
  });
}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Using these techniques has greatly increased productivity and developer happiness for testing client-side code. For an example implementation of this see <a href="https://github.com/craigspaeth/backbone-headless-testing">https://github.com/craigspaeth/backbone-headless-testing</a>.</p>

<p>Looking forward, testing client-side code can be made even better by using a package manager that adds require functionality like <a href="https://github.com/substack/node-browserify">browserify</a>, <a href="https://github.com/component/component">component</a>, or <a href="http://requirejs.org/">require.js</a>. But I&rsquo;ve gone far enough for now, maybe in another blog post (leave a comment if you&rsquo;re interested).</p>
	
			

			

			
				<div class="paging">
					<span class="paging-label">More Reading</span>
					
					<div class="paging-newer">
						<span class="dark-red">Newer</span><span class="decorative-marker">//</span>
						<a class="paging-link" href="/artsy.github.io-hugo/2013/06/21/adding-api-documentation-with-grape-swagger/">Adding API Docs with Grape and Swagger</a>
		            </div>
		            

					
					<div class="paging-older">
						<span class="dark-red">Older</span><span class="decorative-marker">//</span>
			            <a class="paging-link" href="/artsy.github.io-hugo/2013/04/13/bootstrapping-json-data-with-rails-and-backbone-js/">Bootstrapping JSON Data with Rails and Backbone.js</a>
		            </div>
		            
	            </div>
            
          </section>
          
          	
          
        
      <div class="footer">
	<hr class="thin" />
	<div class="pure-menu pure-menu-horizontal pure-menu-open">
		<ul class="footer-menu">
		
		</ul>
	</div>

	<p>&copy; 2017. All rights reserved.</p>
</div>
    </div>
  </div>
	

	

  
</body>
</html>
