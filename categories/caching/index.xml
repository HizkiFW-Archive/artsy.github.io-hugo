<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Caching on Artsy Engineering</title>
    <link>https://hizkifw.github.io/artsy.github.io-hugo/categories/caching/</link>
    <description>Recent content in Caching on Artsy Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Jan 2013 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hizkifw.github.io/artsy.github.io-hugo/categories/caching/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Improving Performance of Mongoid-Cached-Json</title>
      <link>https://hizkifw.github.io/artsy.github.io-hugo/2013/01/20/improving-performance-of-mongoid-cached-json/</link>
      <pubDate>Sun, 20 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://hizkifw.github.io/artsy.github.io-hugo/2013/01/20/improving-performance-of-mongoid-cached-json/</guid>
      <description>&lt;p&gt;Last year, we have open-sourced and made extensive use of two Ruby libraries in our API: &lt;a href=&#34;https://github.com/dblock/mongoid-cached-json&#34;&gt;mongoid-cached-json&lt;/a&gt; and &lt;a href=&#34;https://github.com/artsy/garner&#34;&gt;garner&lt;/a&gt;. Both transform the procedural nightmare of caching and JSON generation into a declarative and easily manageable DSL. It was worth the investment, since our service spends half of its time generating JSON and reading from and writing to Memcached.&lt;/p&gt;

&lt;p&gt;Today we&amp;rsquo;ve released mongoid-cached-json 1.4 with two interesting performance improvements.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RESTful API Caching with Garner</title>
      <link>https://hizkifw.github.io/artsy.github.io-hugo/2012/06/23/restful-api-caching-with-garner/</link>
      <pubDate>Sat, 23 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://hizkifw.github.io/artsy.github.io-hugo/2012/06/23/restful-api-caching-with-garner/</guid>
      <description>&lt;p&gt;Implementing server-side RESTful API caching is hard. In a straightforward API all the expiry decisions can be made automatically based on the URL, but most real world APIs that add requirements around object relationships or user authorization make caching particularly challenging.&lt;/p&gt;

&lt;p&gt;At &lt;a href=&#34;http://goruco.com/&#34;&gt;GoRuCo&lt;/a&gt; we open-sourced &lt;a href=&#34;http://github.com/artsy/garner&#34;&gt;Garner&lt;/a&gt;, a cache implementation of the concepts described in this post. To &amp;ldquo;garner&amp;rdquo; means to gather data from various sources and to make it readily available in one place, kind-of like a cache! Garner works today with the &lt;a href=&#34;http://github.com/intridea/grape&#34;&gt;Grape API framework&lt;/a&gt; and the &lt;a href=&#34;http://github.com/mongoid/mongoid&#34;&gt;Mongoid ODM&lt;/a&gt;. We encourage you to fork the project, extend our library to other systems and contribute your code back, if you find it useful.&lt;/p&gt;

&lt;p&gt;Garner implements the Artsy API caching cookbook that has been tried by fire in production.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Simplifying Model-Level JSON Versioning with Mongoid-Cached-Json</title>
      <link>https://hizkifw.github.io/artsy.github.io-hugo/2012/03/23/simplifying-model-level-json-versioning-with-mongoid-cached-json/</link>
      <pubDate>Fri, 23 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://hizkifw.github.io/artsy.github.io-hugo/2012/03/23/simplifying-model-level-json-versioning-with-mongoid-cached-json/</guid>
      <description>Did you know that Netflix has hundreds of API versions, one for each device? Daniel Jacobson&amp;rsquo;s Techniques for Scaling the Netflix API at QConSF 2011 explained why they chose this model. And while we don&amp;rsquo;t all build distributed services that supply custom-tailored data to thousands of heterogeneous TVs and set-top boxes, we do have to pay close attention to API versioning from day one.
Versioning is hard. Your data models evolve, but you must maintain backward-compatibility for your public interfaces.</description>
    </item>
    
    <item>
      <title>Caching Model JSON with Mongoid-Cached-Json</title>
      <link>https://hizkifw.github.io/artsy.github.io-hugo/2012/02/20/caching-model-json-with-mongoid-cached-json/</link>
      <pubDate>Mon, 20 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>https://hizkifw.github.io/artsy.github.io-hugo/2012/02/20/caching-model-json-with-mongoid-cached-json/</guid>
      <description>Consider the following two Mongoid domain models, Widget and Gadget.
``` ruby widget.rb class Widget include Mongoid::Document
field :name has_many :gadgets end
``` ruby gadget.rb class Gadget include Mongoid::Document field :name field :extras belongs_to :widget end  And an API call that returns a collection of widgets.
get &#39;widgets&#39; do Widget.all.as_json end  Given many widgets, the API makes a subquery to fetch the corresponding gadgets for each widget.
Introducing mongoid-cached-json.</description>
    </item>
    
  </channel>
</rss>